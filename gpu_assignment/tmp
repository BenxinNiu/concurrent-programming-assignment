//void calculate_distance(float trajectory[][2], int num_stop, float *distance);

float read_file() {
    FILE *file = fopen("./sample.txt", "r"); /* should check the result */
    float raw_data[MAX_SOURCE_SIZE];
    float n;
    int idx = 0;
    // prevent stack smashing (idx < MAX_SOURCE_SIZE)
    while (fscanf(file, " %f", &n) == 1 && idx < MAX_SOURCE_SIZE) {
        raw_data[idx] = n;
        idx++;
    }
    int num_trajectory = (int) raw_data[0];
    int num_stop = (int) raw_data[1];
    float cooked_data[num_trajectory][num_stop][2];
    int trajectory_idx = 0;
    int stop_idx = 0;
    int k = 2;
    while (k < num_trajectory * num_stop * 2 + 2) {
//            printf("%f\n" , raw_data[i]);
//            printf("%f\n" , raw_data[i+1]);
        cooked_data[trajectory_idx][stop_idx][0] = raw_data[k];
        cooked_data[trajectory_idx][stop_idx][1] = raw_data[k + 1];
        if (stop_idx == num_stop - 1) {
            trajectory_idx++;
            stop_idx = 0;
        } else {
            stop_idx++;
        }
        k = k + 2;
    }
}


//    for(int i=0; i<num_trajectory; i++){
//        printf("\n Trajectory %d: ", i);
//        for(int j=0; j<num_stop; j++){
//            printf(" %f %f ",cooked_data[i][j][0], cooked_data[i][j][1]);
//        }
//    }
//    printf("\n distance: %f ", calculate_distance(cooked_data[0], num_stop));
//
//    printf("\n distance: %f ", calculate_distance(cooked_data[1], num_stop));
//
//    printf("\n distance: %f ", calculate_distance(cooked_data[2], num_stop));
//
//    printf("\n distance: %f ", calculate_distance(cooked_data[3], num_stop));
}

//void calculate_distance(float trajectory[][2], int num_stop, float *distance){
//    if (num_stop < 1){
//        printf("Exiting, a trajectory cannot have a number of stop of zero");
//        exit(1);
//    }
//    float x = pow(trajectory[0][0] - 0, 2);
//    float y = pow(trajectory[0][1] - 0, 2);
//    float sum = sqrt(x+y);
//    if (num_stop == 1) {
//        distance[0] = sum;
//    }
//    else {
//        for(int i=1; i<num_stop; i++){
//            x = pow(trajectory[i][0] - trajectory[i-1][0], 2);
//            y = pow(trajectory[i][1] - trajectory[i-1][1], 2);
//            sum += sqrt(x+y);
//        }
//        distance[0] = sum;
//    }
//}


 float x = pow(trajectory[i][0][0] - 0, 2);
        float y = pow(trajectory[i][0][1] - 0, 2);
        float sum = sqrt(x+y);
        if (*num_stop == 1) {
            distance[1] = 1;
        }
        else {
            for(int j=1; j<*num_stop; j++){
                x = pow(trajectory[i][j][0] - trajectory[i][j-1][0], 2);
                y = pow(trajectory[i][j][1] - trajectory[i][j-1][1], 2);
                sum += sqrt(x+y);
            }
            distance[1] = 1;
        }
